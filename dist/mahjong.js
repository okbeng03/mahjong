'use strict';

var _ = require('lodash');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

var Player$1 = /** @class */ (function () {
    function Player(id, name, pick, isAI) {
        if (isAI === void 0) { isAI = false; }
        this.id = id;
        this.name = name;
        this.pick = pick;
        this.isAI = isAI;
    }
    return Player;
}());

//# sourceMappingURL=player.js.map

var Card;
(function (Card) {
    // 万
    Card[Card["CharacterOne"] = 1] = "CharacterOne";
    Card[Card["CharacterTwo"] = 2] = "CharacterTwo";
    Card[Card["CharacterThree"] = 3] = "CharacterThree";
    Card[Card["CharacterFour"] = 4] = "CharacterFour";
    Card[Card["CharacterFive"] = 5] = "CharacterFive";
    Card[Card["CharacterSix"] = 6] = "CharacterSix";
    Card[Card["CharacterSeven"] = 7] = "CharacterSeven";
    Card[Card["CharacterEight"] = 8] = "CharacterEight";
    Card[Card["CharacterNight"] = 9] = "CharacterNight";
    // 筒
    Card[Card["DotOne"] = 11] = "DotOne";
    Card[Card["DotTwo"] = 12] = "DotTwo";
    Card[Card["DotThree"] = 13] = "DotThree";
    Card[Card["DotFour"] = 14] = "DotFour";
    Card[Card["DotFive"] = 15] = "DotFive";
    Card[Card["DotSix"] = 16] = "DotSix";
    Card[Card["DotSeven"] = 17] = "DotSeven";
    Card[Card["DotEight"] = 18] = "DotEight";
    Card[Card["DotNight"] = 19] = "DotNight";
    // 条
    Card[Card["BambooOne"] = 21] = "BambooOne";
    Card[Card["BambooTwo"] = 22] = "BambooTwo";
    Card[Card["BambooThree"] = 23] = "BambooThree";
    Card[Card["BambooFour"] = 24] = "BambooFour";
    Card[Card["BambooFive"] = 25] = "BambooFive";
    Card[Card["BambooSix"] = 26] = "BambooSix";
    Card[Card["BambooSeven"] = 27] = "BambooSeven";
    Card[Card["BambooEight"] = 28] = "BambooEight";
    Card[Card["BambooNight"] = 29] = "BambooNight";
    // 风牌
    Card[Card["East"] = 31] = "East";
    Card[Card["South"] = 33] = "South";
    Card[Card["West"] = 35] = "West";
    Card[Card["North"] = 37] = "North";
    // 箭牌
    Card[Card["Green"] = 41] = "Green";
    Card[Card["Red"] = 43] = "Red";
    Card[Card["White"] = 45] = "White";
    // 花
    Card[Card["Spring"] = 51] = "Spring";
    Card[Card["Summer"] = 52] = "Summer";
    Card[Card["Autumn"] = 53] = "Autumn";
    Card[Card["Winter"] = 54] = "Winter";
    Card[Card["Plum"] = 55] = "Plum";
    Card[Card["Orchid"] = 56] = "Orchid";
    Card[Card["Bamboo"] = 57] = "Bamboo";
    Card[Card["Chrysanthemum"] = 58] = "Chrysanthemum";
})(Card || (Card = {}));

var ClaimType;
(function (ClaimType) {
    ClaimType[ClaimType["None"] = 0] = "None";
    ClaimType[ClaimType["Chow"] = 1] = "Chow";
    ClaimType[ClaimType["Pong"] = 2] = "Pong";
    ClaimType[ClaimType["Expose"] = 3] = "Expose";
    ClaimType[ClaimType["ExposeSelfDraw"] = 4] = "ExposeSelfDraw";
    ClaimType[ClaimType["ConcealedKong"] = 5] = "ConcealedKong";
    ClaimType[ClaimType["Flower"] = 6] = "Flower";
    ClaimType[ClaimType["Win"] = 7] = "Win";
    ClaimType[ClaimType["SelfDraw"] = 8] = "SelfDraw";
    ClaimType[ClaimType["Kong"] = 9] = "Kong";
    ClaimType[ClaimType["FirstFollow"] = 10] = "FirstFollow";
    ClaimType[ClaimType["BaoPai"] = 11] = "BaoPai"; // 包牌
})(ClaimType || (ClaimType = {}));

var Pick;
(function (Pick) {
    Pick[Pick["East"] = 1] = "East";
    Pick[Pick["South"] = 2] = "South";
    Pick[Pick["West"] = 3] = "West";
    Pick[Pick["North"] = 4] = "North";
})(Pick || (Pick = {}));

var NumberCard = [
    Card.CharacterOne,
    Card.CharacterTwo,
    Card.CharacterThree,
    Card.CharacterFour,
    Card.CharacterFive,
    Card.CharacterSix,
    Card.CharacterSeven,
    Card.CharacterEight,
    Card.CharacterNight,
    Card.DotOne,
    Card.DotTwo,
    Card.DotThree,
    Card.DotFour,
    Card.DotFive,
    Card.DotSix,
    Card.DotSeven,
    Card.DotEight,
    Card.DotNight,
    Card.BambooOne,
    Card.BambooTwo,
    Card.BambooThree,
    Card.BambooFour,
    Card.BambooFive,
    Card.BambooSix,
    Card.BambooSeven,
    Card.BambooEight,
    Card.BambooNight
];
var WindCard = [
    Card.East,
    Card.South,
    Card.West,
    Card.North
];
var DragonCard = [
    Card.Green,
    Card.Red,
    Card.White
];
var FlowerCard = [
    Card.Spring,
    Card.Summer,
    Card.Autumn,
    Card.Winter,
    Card.Plum,
    Card.Orchid,
    Card.Bamboo,
    Card.Chrysanthemum
];
// 拼接
function concatTiles(cards, tiles) {
    for (var _i = 0, cards_1 = cards; _i < cards_1.length; _i++) {
        var i = cards_1[_i];
        tiles = tiles.concat([i, i, i, i]);
    }
    return tiles;
}
/**
 * 获取默认牌
 * @param hasWind 是否有风牌
 * @param hasDragon 是否有箭牌
 * @param hasFlower 是否有花
 */
var getTiles = function (hasWind, hasDragon, hasFlower) {
    if (hasWind === void 0) { hasWind = true; }
    if (hasDragon === void 0) { hasDragon = true; }
    if (hasFlower === void 0) { hasFlower = true; }
    var tiles = [];
    tiles = concatTiles(NumberCard, tiles);
    if (hasWind) {
        tiles = concatTiles(WindCard, tiles);
    }
    if (hasDragon) {
        tiles = concatTiles(DragonCard, tiles);
    }
    if (hasFlower) {
        for (var _i = 0, FlowerCard_1 = FlowerCard; _i < FlowerCard_1.length; _i++) {
            var i = FlowerCard_1[_i];
            tiles.push(i);
        }
    }
    return tiles;
};
var cardMaps = {
    // 万
    CharacterOne: '一万',
    CharacterTwo: '二万',
    CharacterThree: '三万',
    CharacterFour: '四万',
    CharacterFive: '五万',
    CharacterSix: '六万',
    CharacterSeven: '七万',
    CharacterEight: '八万',
    CharacterNight: '九万',
    // 筒
    DotOne: '一筒',
    DotTwo: '二筒',
    DotThree: '三筒',
    DotFour: '四筒',
    DotFive: '五筒',
    DotSix: '六筒',
    DotSeven: '七筒',
    DotEight: '八筒',
    DotNight: '九筒',
    // 条
    BambooOne: '一条',
    BambooTwo: '二条',
    BambooThree: '三条',
    BambooFour: '四条',
    BambooFive: '五条',
    BambooSix: '六条',
    BambooSeven: '七条',
    BambooEight: '八条',
    BambooNight: '九条',
    // 风牌
    East: '东风',
    South: '南风',
    West: '西风',
    North: '北风',
    // 箭牌
    Green: '发财',
    Red: '红中',
    White: '白板',
    // 花
    Spring: '春',
    Summer: '夏',
    Autumn: '秋',
    Winter: '冬',
    Plum: '梅',
    Orchid: '兰',
    Chrysanthemum: '菊',
    Bamboo: '竹'
};

// 洗牌：随机打乱顺序
var shuffleTiles = function (tiles) {
    return _.shuffle(_.shuffle(_.shuffle(tiles)));
};
// 通过id获取麻将名
var getTileSuit = function (tile) {
    return cardMaps[Card[tile]];
};
// 通过麻将名获取id

// 排序
var sortTiles = function (tiles) {
    return tiles.slice().sort(function (a, b) {
        return a - b;
    });
};
// 批量导出麻将名
var batchTilesSuit = function (tiles, s) {
    if (s === void 0) { s = ','; }
    var suits = tiles.map(getTileSuit);
    return suits.join(s);
};
// 批量导出id

//# sourceMappingURL=tile.js.map

var assembly = { "3": [111, 3], "6": [222, 1221, 11211, 111111, 411, 141, 114, 1113, 3111, 33], "9": [333, 2331, 22311, 222111, 2223, 1332, 12321, 122211, 1221111, 4221, 1224, 12213, 11322, 112221, 1121211, 11211111, 41211, 14211, 11241, 11214, 112113, 111222, 1111221, 11111211, 111111111, 411111, 141111, 114111, 111411, 111141, 111114, 1111113, 441, 414, 4113, 144, 1413, 1143, 1113111, 11133, 3222, 31221, 311211, 3111111, 3411, 3141, 3114, 31113, 33111], "12": [444, 3441, 33411, 333111, 3333, 2442, 23421, 233211, 2331111, 2334, 23313, 22422, 223221, 2231211, 22311111, 22341, 22314, 223113, 222222, 2221221, 22211211, 222111111, 222411, 222141, 222114, 2221113, 2223111, 22233, 1443, 13431, 133311, 1332111, 4332, 13323, 12432, 123321, 1232211, 12321111, 42321, 12324, 123213, 122322, 1222221, 12221211, 122211111, 422211, 122241, 122214, 1222113, 1221222, 12211221, 122111211, 4221111, 1224111, 1221411, 1221141, 1221114, 12211113, 4224, 42213, 12243, 12213111, 122133, 11433, 113331, 1132311, 11322111, 41322, 14322, 113223, 112332, 1122321, 11222211, 112221111, 412221, 142221, 112224, 1122213, 1121322, 11212221, 112121211, 4121211, 1421211, 1124211, 1121241, 1121214, 11212113, 11211222, 112111221, 311211111, 41211111, 14211111, 11241111, 11214111, 11211411, 11211141, 11211114, 44211, 41241, 41214, 412113, 14241, 14214, 142113, 11244, 112413, 112143, 112113111, 1121133, 111333, 1112331, 11122311, 111222111, 411222, 141222, 114222, 1112223, 1111332, 11112321, 111122211, 4111221, 1411221, 1141221, 1114221, 1111224, 11112213, 11111322, 111112221, 311111211, 41111211, 14111211, 11411211, 11141211, 11114211, 11111241, 11111214, 111111222, 411111111, 141111111, 114111111, 111411111, 111141111, 111114111, 111111411, 111111141, 111111114, 441111, 414111, 411411, 411141, 411114, 4111113, 144111, 141411, 141141, 141114, 1411113, 114411, 114141, 114114, 1141113, 111441, 111414, 1114113, 111144, 1111413, 1111143, 11111133, 4413, 4143, 4113111, 41133, 1413111, 14133, 1143111, 1113222, 11131221, 111311211, 1113411, 1113141, 1113114, 11131113, 11133111, 32331, 322311, 3222111, 32223, 31332, 312321, 3122211, 31221111, 34221, 31224, 312213, 311322, 3112221, 31121211, 341211, 314211, 311241, 311214, 3112113, 3111222, 31111221, 3411111, 3141111, 3114111, 3111411, 3111141, 3111114, 31111113, 3414, 34113, 3144, 31413, 31143, 31113111, 311133, 33222, 331221, 3311211, 33111111, 33141, 33114, 331113] };
var eyeAssembly = { "2": [2], "5": [311, 2111, 23, 131, 32, 113, 1112], "8": [422, 3221, 31211, 311111, 341, 314, 3113, 2222, 21221, 211211, 2111111, 2411, 2141, 2114, 21113, 23111, 233, 242, 1421, 13211, 131111, 431, 134, 1313, 3311, 32111, 323, 224, 1241, 11411, 113111, 413, 143, 1133, 3131, 332, 1223, 11231, 111311, 1112111, 4112, 1412, 1142, 11123, 12212, 11213, 111131, 11132, 31112, 112112, 111113, 1111112], "11": [4331, 42311, 422111, 4223, 3332, 32321, 322211, 3221111, 3224, 32213, 31322, 312221, 3121211, 31211111, 34211, 31241, 31214, 312113, 311222, 3111221, 31111211, 311111111, 341111, 314111, 311411, 311141, 311114, 3111113, 3113111, 344, 3413, 3143, 31133, 2333, 22331, 222311, 2222111, 22223, 21332, 212321, 2122211, 21221111, 24221, 21224, 212213, 211322, 2112221, 21121211, 211211111, 241211, 214211, 211241, 211214, 2112113, 2111222, 21111221, 211111211, 2411111, 2141111, 2114111, 2111411, 2111141, 2111114, 21111113, 21113111, 2441, 2414, 24113, 2144, 21413, 21143, 211133, 23222, 231221, 2311211, 23111111, 23411, 23141, 23114, 231113, 233111, 24311, 242111, 2423, 14321, 142211, 1421111, 4421, 1424, 14213, 13322, 132221, 1321211, 13211111, 43211, 13241, 13214, 132113, 131222, 1311221, 13111211, 131111111, 431111, 134111, 131411, 131141, 131114, 1311113, 1313111, 434, 4313, 1343, 13133, 3422, 33221, 331211, 3311111, 3341, 3314, 33113, 32222, 321221, 3211211, 32111111, 32411, 32141, 32114, 321113, 323111, 3233, 224111, 2243, 124211, 1241111, 4241, 1244, 12413, 114221, 1141211, 11411111, 41411, 14411, 11441, 11414, 114113, 113222, 1131221, 11311211, 113111111, 413111, 143111, 113411, 113141, 113114, 1131113, 1133111, 443, 4133, 1433, 11333, 3242, 31421, 313211, 3131111, 3431, 3134, 31313, 33311, 332111, 3323, 1334, 12341, 122411, 1223111, 12233, 11342, 112421, 1123211, 11231111, 41231, 14231, 11234, 112313, 111422, 1113221, 11131211, 111311111, 411311, 141311, 114311, 111341, 111314, 1113113, 1112222, 11121221, 111211211, 4112111, 1412111, 1142111, 1112411, 1112141, 1112114, 11121113, 11123111, 4412, 4142, 41123, 1442, 14123, 11423, 111233, 33131, 23312, 22313, 222131, 22232, 12323, 122231, 1221311, 12212111, 42212, 12242, 122123, 11324, 112241, 1121411, 11213111, 41213, 11243, 112133, 111242, 1111421, 11113211, 111131111, 411131, 141131, 114131, 111431, 111134, 1111313, 1113311, 11132111, 41132, 14132, 11432, 111323, 31223, 311231, 3111311, 31112111, 34112, 31412, 31142, 311123, 223112, 222113, 123212, 122213, 1221131, 122132, 112223, 1121231, 11211311, 112112111, 412112, 142112, 112412, 112142, 1121123, 111224, 1111241, 11111411, 111113111, 411113, 141113, 111413, 111143, 1111133, 1113131, 111332, 312212, 311213, 3111131, 311132, 331112, 2221112, 1222112, 1221113, 1122212, 1121213, 11211131, 1121132, 1111223, 11111231, 111111311, 4111112, 1411112, 1141112, 1114112, 1111412, 1111142, 11111123, 3112112, 12211112, 11212112, 11211113, 11112212, 11111213, 111111131, 11111132, 11131112, 31111112, 112111112, 111112112, 111111113], "14": [4442, 43421, 433211, 4331111, 4334, 43313, 42422, 423221, 4231211, 42311111, 42341, 42314, 423113, 422222, 4221221, 42211211, 422111111, 422411, 422141, 422114, 4221113, 4223111, 42233, 3443, 33431, 333311, 3332111, 33323, 32432, 323321, 3232211, 32321111, 32324, 323213, 322322, 3222221, 32221211, 322211111, 322241, 322214, 3222113, 3221222, 32211221, 322111211, 3224111, 3221411, 3221141, 3221114, 32211113, 32213111, 32243, 322133, 31433, 313331, 3132311, 31322111, 34322, 313223, 312332, 3122321, 31222211, 312221111, 342221, 312224, 3122213, 3121322, 31212221, 312121211, 3421211, 3124211, 3121241, 3121214, 31212113, 31211222, 312111221, 34211111, 31241111, 31214111, 31211411, 31211141, 31211114, 312111113, 312113111, 34241, 34214, 342113, 31244, 312413, 312143, 3121133, 311333, 3112331, 31122311, 311222111, 341222, 314222, 3112223, 3111332, 31112321, 311122211, 3411221, 3141221, 3114221, 3111224, 31112213, 31111322, 311112221, 34111211, 31411211, 31141211, 31114211, 31111241, 31111214, 311112113, 311111222, 341111111, 314111111, 311411111, 311141111, 311114111, 311111411, 311111141, 311111114, 344111, 341411, 341141, 341114, 3411113, 314411, 314141, 314114, 3141113, 311441, 311414, 3114113, 311144, 3111413, 3111143, 31111133, 3113222, 31131221, 311311211, 3413111, 3143111, 3113411, 3113141, 3113114, 31131113, 31133111, 34133, 2444, 23441, 233411, 2333111, 23333, 22442, 223421, 2233211, 22331111, 22334, 223313, 222422, 2223221, 22231211, 222311111, 222341, 222314, 2223113, 2222222, 22221221, 222211211, 2222411, 2222141, 2222114, 22221113, 22223111, 222233, 21443, 213431, 2133311, 21332111, 24332, 213323, 212432, 2123321, 21232211, 212321111, 242321, 212324, 2123213, 2122322, 21222221, 212221211, 2422211, 2122241, 2122214, 21222113, 21221222, 212211221, 24221111, 21224111, 21221411, 21221141, 21221114, 212211113, 212213111, 24224, 242213, 212243, 2122133, 211433, 2113331, 21132311, 211322111, 241322, 214322, 2113223, 2112332, 21122321, 211222211, 2412221, 2142221, 2112224, 21122213, 21121322, 211212221, 24121211, 21421211, 21124211, 21121241, 21121214, 211212113, 211211222, 241211111, 214211111, 211241111, 211214111, 211211411, 211211141, 211211114, 244211, 241241, 241214, 2412113, 214241, 214214, 2142113, 211244, 2112413, 2112143, 21121133, 2111333, 21112331, 211122311, 2411222, 2141222, 2114222, 21112223, 21111332, 211112321, 24111221, 21411221, 21141221, 21114221, 21111224, 211112213, 211111322, 241111211, 214111211, 211411211, 211141211, 211114211, 211111241, 211111214, 2441111, 2414111, 2411411, 2411141, 2411114, 24111113, 2144111, 2141411, 2141141, 2141114, 21411113, 2114411, 2114141, 2114114, 21141113, 2111441, 2111414, 21114113, 2111144, 21111413, 21111143, 211111133, 21113222, 211131221, 24113111, 21413111, 21143111, 21113411, 21113141, 21113114, 211131113, 211133111, 24413, 24143, 241133, 214133, 232331, 2322311, 23222111, 232223, 231332, 2312321, 23122211, 231221111, 234221, 231224, 2312213, 2311322, 23112221, 231121211, 2341211, 2314211, 2311241, 2311214, 23112113, 23111222, 231111221, 23411111, 23141111, 23114111, 23111411, 23111141, 23111114, 231111113, 231113111, 23414, 234113, 23144, 231413, 231143, 2311133, 233222, 2331221, 23311211, 233111111, 233141, 233114, 2331113, 24422, 243221, 2431211, 24311111, 24341, 24314, 243113, 242222, 2421221, 24211211, 242111111, 242411, 242141, 242114, 2421113, 2423111, 24233, 14432, 143321, 1432211, 14321111, 44321, 14324, 143213, 142322, 1422221, 14221211, 142211111, 442211, 142241, 142214, 1422113, 1421222, 14211221, 142111211, 4421111, 1424111, 1421411, 1421141, 1421114, 14211113, 14213111, 4424, 44213, 14243, 142133, 13433, 133331, 1332311, 13322111, 43322, 133223, 132332, 1322321, 13222211, 132221111, 432221, 132224, 1322213, 1321322, 13212221, 132121211, 4321211, 1324211, 1321241, 1321214, 13212113, 13211222, 132111221, 43211111, 13241111, 13214111, 13211411, 13211141, 13211114, 132111113, 132113111, 43241, 43214, 432113, 13244, 132413, 132143, 1321133, 131333, 1312331, 13122311, 131222111, 431222, 134222, 1312223, 1311332, 13112321, 131122211, 4311221, 1341221, 1314221, 1311224, 13112213, 13111322, 131112221, 43111211, 13411211, 13141211, 13114211, 13111241, 13111214, 131112113, 131111222, 431111111, 134111111, 131411111, 131141111, 131114111, 131111411, 131111141, 131111114, 434111, 431411, 431141, 431114, 4311113, 134411, 134141, 134114, 1341113, 131441, 131414, 1314113, 131144, 1311413, 1311143, 13111133, 1313222, 13131221, 131311211, 4313111, 1343111, 1313411, 1313141, 1313114, 13131113, 13133111, 4343, 43133, 34331, 342311, 3422111, 34223, 33332, 332321, 3322211, 33221111, 33224, 332213, 331322, 3312221, 33121211, 331211111, 334211, 331241, 331214, 3312113, 3311222, 33111221, 331111211, 3341111, 3314111, 3311411, 3311141, 3311114, 33111113, 33113111, 3344, 33413, 33143, 331133, 32333, 322331, 3222311, 32222111, 322223, 321332, 3212321, 32122211, 321221111, 324221, 321224, 3212213, 3211322, 32112221, 321121211, 3241211, 3214211, 3211241, 3211214, 32112113, 32111222, 321111221, 32411111, 32141111, 32114111, 32111411, 32111141, 32111114, 321111113, 321113111, 32441, 32414, 324113, 32144, 321413, 321143, 3211133, 323222, 3231221, 32311211, 323111111, 323411, 323141, 323114, 3231113, 3233111, 224222, 2241221, 22411211, 224111111, 224411, 224141, 224114, 2241113, 2243111, 22433, 124322, 1242221, 12421211, 124211111, 424211, 124241, 124214, 1242113, 1241222, 12411221, 124111211, 4241111, 1244111, 1241411, 1241141, 1241114, 12411113, 12413111, 4244, 42413, 12443, 124133, 114332, 1142321, 11422211, 114221111, 414221, 144221, 114224, 1142213, 1141322, 11412221, 114121211, 4141211, 1441211, 1144211, 1141241, 1141214, 11412113, 11411222, 114111221, 41411111, 14411111, 11441111, 11414111, 11411411, 11411141, 11411114, 114111113, 114113111, 44411, 41441, 41414, 414113, 14441, 14414, 144113, 11444, 114413, 114143, 1141133, 113333, 1132331, 11322311, 113222111, 413222, 143222, 1132223, 1131332, 11312321, 113122211, 4131221, 1431221, 1134221, 1131224, 11312213, 11311322, 113112221, 41311211, 14311211, 11341211, 11314211, 11311241, 11311214, 113112113, 113111222, 413111111, 143111111, 113411111, 113141111, 113114111, 113111411, 113111141, 113111114, 443111, 413411, 413141, 413114, 4131113, 143411, 143141, 143114, 1431113, 113441, 113414, 1134113, 113144, 1131413, 1131143, 11311133, 1133222, 11331221, 113311211, 4133111, 1433111, 1133411, 1133141, 1133114, 11331113, 11333111, 4433, 41333, 14333, 324311, 3242111, 32423, 314321, 3142211, 31421111, 34421, 31424, 314213, 313322, 3132221, 31321211, 313211111, 343211, 313241, 313214, 3132113, 3131222, 31311221, 313111211, 3431111, 3134111, 3131411, 3131141, 3131114, 31311113, 31313111, 3434, 34313, 31343, 313133, 33422, 333221, 3331211, 33311111, 33341, 33314, 333113, 332222, 3321221, 33211211, 332111111, 332411, 332141, 332114, 3321113, 3323111, 33233, 1334111, 13343, 1234211, 12341111, 12344, 123413, 1224221, 12241211, 122411111, 122441, 122414, 1224113, 1223222, 12231221, 122311211, 1223411, 1223141, 1223114, 12231113, 12233111, 122333, 1134311, 11342111, 41342, 14342, 113423, 1124321, 11242211, 112421111, 412421, 142421, 112424, 1124213, 1123322, 11232221, 112321211, 4123211, 1423211, 1123241, 1123214, 11232113, 11231222, 112311221, 41231111, 14231111, 11234111, 11231411, 11231141, 11231114, 112311113, 112313111, 44231, 41234, 412313, 14234, 142313, 112343, 1123133, 1114331, 11142311, 111422111, 411422, 141422, 114422, 1114223, 1113332, 11132321, 111322211, 4113221, 1413221, 1143221, 1113224, 11132213, 11131322, 111312221, 41131211, 14131211, 11431211, 11134211, 11131241, 11131214, 111312113, 111311222, 411311111, 141311111, 114311111, 111341111, 111314111, 111311411, 111311141, 111311114, 441311, 414311, 411341, 411314, 4113113, 144311, 141341, 141314, 1413113, 114341, 114314, 1143113, 111344, 1113413, 1113143, 11131133, 1112333, 11122331, 111222311, 4112222, 1412222, 1142222, 11122223, 11121332, 111212321, 41121221, 14121221, 11421221, 11124221, 11121224, 111212213, 111211322, 411211211, 141211211, 114211211, 111241211, 111214211, 111211241, 111211214, 4412111, 4142111, 4112411, 4112141, 4112114, 41121113, 1442111, 1412411, 1412141, 1412114, 14121113, 1142411, 1142141, 1142114, 11421113, 1112441, 1112414, 11124113, 1112144, 11121413, 11121143, 111211133, 11123222, 111231221, 41123111, 14123111, 11423111, 11123411, 11123141, 11123114, 111231113, 111233111, 44123, 41423, 411233, 14423, 141233, 114233, 33242, 331421, 3313211, 33131111, 33134, 331313, 34412, 333131, 23423, 233231, 2331311, 23312111, 23342, 233123, 22424, 223241, 2231411, 22313111, 22343, 223133, 222242, 2221421, 22213211, 222131111, 222431, 222134, 2221313, 2223311, 22232111, 222323, 12434, 123341, 1232411, 12323111, 42323, 123233, 122342, 1222421, 12223211, 122231111, 422231, 122234, 1222313, 1221422, 12213221, 122131211, 4221311, 1224311, 1221341, 1221314, 12213113, 12212222, 122121221, 42212111, 12242111, 12212411, 12212141, 12212114, 122121113, 122123111, 42242, 422123, 122423, 1221233, 11324111, 41324, 113243, 11224211, 112241111, 412241, 112244, 1122413, 11214221, 112141211, 4121411, 1124411, 1121441, 1121414, 11214113, 11213222, 112131221, 41213111, 11243111, 11213411, 11213141, 11213114, 112131113, 112133111, 41243, 412133, 112433, 1121333, 11124311, 111242111, 411242, 141242, 114242, 1112423, 11114321, 111142211, 4111421, 1411421, 1141421, 1114421, 1111424, 11114213, 11113322, 111132221, 41113211, 14113211, 11413211, 11143211, 11113241, 11113214, 111132113, 111131222, 411131111, 141131111, 114131111, 111431111, 111134111, 111131411, 111131141, 111131114, 441131, 414131, 411431, 411134, 4111313, 144131, 141431, 141134, 1411313, 114431, 114134, 1141313, 111434, 1114313, 1111343, 11113133, 1113422, 11133221, 111331211, 4113311, 1413311, 1143311, 1113341, 1113314, 11133113, 11132222, 111321221, 41132111, 14132111, 11432111, 11132411, 11132141, 11132114, 111321113, 111323111, 44132, 41432, 411323, 141323, 114323, 1113233, 31334, 312341, 3122411, 31223111, 312233, 311342, 3112421, 31123211, 311231111, 341231, 314231, 311234, 3112313, 3111422, 31113221, 311131211, 3411311, 3141311, 3114311, 3111341, 3111314, 31113113, 31112222, 311121221, 34112111, 31412111, 31142111, 31112411, 31112141, 31112114, 311121113, 311123111, 34142, 341123, 31442, 314123, 311423, 3111233, 334112, 234212, 233213, 2331131, 233132, 223223, 2231231, 22311311, 223112111, 223412, 223142, 2231123, 222224, 2221241, 22211411, 222113111, 222413, 222143, 2221133, 2223131, 222332, 134312, 133313, 1332131, 133232, 123323, 1232231, 12321311, 123212111, 423212, 123242, 1232123, 122324, 1222241, 12221411, 122213111, 422213, 122243, 1222133, 1221242, 12211421, 122113211, 4221131, 1224131, 1221431, 1221134, 12211313, 12213311, 122132111, 422132, 122432, 1221323, 112334, 1122341, 11222411, 112223111, 412223, 142223, 1122233, 1121342, 11212421, 112123211, 4121231, 1421231, 1124231, 1121234, 11212313, 11211422, 112113221, 41211311, 14211311, 11241311, 11214311, 11211341, 11211314, 112113113, 112112222, 412112111, 142112111, 112412111, 112142111, 112112411, 112112141, 112112114, 442112, 412412, 412142, 4121123, 142412, 142142, 1421123, 112442, 1124123, 1121423, 11211233, 111224111, 411224, 141224, 1112243, 111124211, 4111241, 1411241, 1114241, 1111244, 11112413, 111114221, 41111411, 14111411, 11141411, 11114411, 11111441, 11111414, 111114113, 111113222, 411113111, 141113111, 111413111, 111143111, 111113411, 111113141, 111113114, 441113, 411413, 411143, 4111133, 141413, 141143, 1411133, 111443, 1114133, 1111433, 11111333, 1113242, 11131421, 111313211, 4113131, 1413131, 1143131, 1113431, 1113134, 11131313, 11133311, 111332111, 411332, 141332, 1113323, 323312, 322313, 3222131, 322232, 312323, 3122231, 31221311, 312212111, 342212, 312242, 3122123, 311324, 3112241, 31121411, 311213111, 341213, 311243, 3112133, 3111242, 31111421, 311113211, 3411131, 3141131, 3114131, 3111431, 3111134, 31111313, 31113311, 311132111, 341132, 314132, 311432, 3111323, 331223, 3311231, 33111311, 331112111, 331412, 331142, 3311123, 3331112, 2332112, 2232212, 2231213, 22311131, 2231132, 2221223, 22211231, 222111311, 2224112, 2221412, 2221142, 22211123, 1333112, 1332113, 1233212, 1232213, 12321131, 1232132, 1222223, 12221231, 122211311, 4222112, 1222412, 1222142, 12221123, 1221224, 12211241, 122111411, 1221413, 1221143, 12211133, 12213131, 1221332, 1133312, 1132313, 11322131, 1132232, 1122323, 11222231, 112221311, 4122212, 1422212, 1122242, 11222123, 1121324, 11212241, 112121411, 4121213, 1421213, 1121243, 11212133, 11211242, 112111421, 41211131, 14211131, 11241131, 11214131, 11211431, 11211134, 112111313, 112113311, 4121132, 1421132, 1124132, 1121432, 11211323, 1111334, 11112341, 111122411, 4111223, 1411223, 1141223, 11112233, 11111342, 111112421, 41111231, 14111231, 11411231, 11141231, 11114231, 11111234, 111112313, 111111422, 411111311, 141111311, 114111311, 111411311, 111141311, 111114311, 111111341, 111111314, 4411112, 4141112, 4114112, 4111412, 4111142, 41111123, 1441112, 1414112, 1411412, 1411142, 14111123, 1144112, 1141412, 1141142, 11411123, 1114412, 1114142, 11141123, 1111442, 11114123, 11111423, 111111233, 11133131, 3223112, 3123212, 31221131, 3122132, 31121231, 311211311, 3412112, 3142112, 3112412, 3112142, 31121123, 31113131, 3312212, 3311213, 33111131, 3311132, 23311112, 22312112, 22311113, 22212212, 22211213, 222111131, 22211132, 22231112, 13321112, 12322112, 12321113, 12222212, 12221213, 122211131, 12221132, 12211223, 122111231, 42211112, 12241112, 12214112, 12211412, 12211142, 122111123, 11323112, 11322113, 11223212, 11222213, 112221131, 11222132, 11212223, 112121231, 41212112, 14212112, 11242112, 11212412, 11212142, 112121123, 11211224, 112111241, 41211113, 11241113, 11211413, 11211143, 112111133, 112113131, 11211332, 11123312, 11122313, 111222131, 11122232, 11112323, 111122231, 41112212, 14112212, 11412212, 11142212, 11112242, 111122123, 11111324, 111112241, 41111213, 14111213, 11411213, 11141213, 11111243, 111112133, 111111242, 411111131, 141111131, 114111131, 111411131, 111141131, 111114131, 111111431, 111111134, 41111132, 14111132, 11411132, 11141132, 11114132, 11111432, 111111323, 11131223, 111311231, 41131112, 14131112, 11431112, 11134112, 11131412, 11131142, 111311123, 32221112, 31222112, 31221113, 31122212, 31121213, 311211131, 31121132, 31111223, 311111231, 34111112, 31411112, 31141112, 31114112, 31111412, 31111142, 311111123, 33112112, 223111112, 222112112, 222111113, 123211112, 122212112, 122211113, 122112212, 122111213, 122111132, 122131112, 113221112, 112222112, 112221113, 112122212, 112121213, 112121132, 112111223, 412111112, 142111112, 112411112, 112141112, 112114112, 112111412, 112111142, 111223112, 111222113, 111123212, 111122213, 111122132, 111112223, 411112112, 141112112, 114112112, 111412112, 111142112, 111112412, 111112142, 111111224, 411111113, 141111113, 111411113, 111141113, 111111413, 111111143, 111111332, 111312212, 111311213, 111311132, 111331112, 312211112, 311212112, 311211113, 311112212, 311111213, 311111132, 311131112, 331111112] };
//# sourceMappingURL=data.js.map

// 基础规则
var thirteenOrphans = [
    Card.CharacterOne,
    Card.CharacterNight,
    Card.DotOne,
    Card.DotNight,
    Card.BambooOne,
    Card.BambooNight,
    Card.East,
    Card.South,
    Card.West,
    Card.North,
    Card.Green,
    Card.Red,
    Card.White
];
// 检查是否胡牌
function canWin(player, tile) {
    if (tile === void 0) { tile = 0; }
    var tiles;
    if (tile > 0) {
        tiles = sortTiles(player.handTiles.slice().concat([tile]));
    }
    else {
        tiles = sortTiles(player.handTiles.slice());
    }
    var remainTiles = checkMelds(tiles, player);
    if (remainTiles.length && player.handTiles.length === 14) {
        // 七小对，十三幺
        var readyTiles = checkPair(player.handTiles);
        if (!readyTiles.length) {
            return true;
        }
        var readyTile = checkUniq(player.handTiles);
        if (readyTile === 0) {
            return true;
        }
    }
    player.remainTiles = remainTiles;
    return !remainTiles.length;
}
// 检查是否可以听牌
function canReadyHand(player) {
    var tiles = sortTiles(player.handTiles.slice());
    var remainTiles = checkMelds(tiles, player);
    // 找出剩余的牌
    if (remainTiles.length) {
        // 找出是否可以听牌、听什么牌
        player.remainTiles = remainTiles;
        checkReadyHand(player);
    }
}
// 花胡
function canFlowerWin(tiles, tile) {
    var len = tiles.length;
    if (len >= 4) {
        tiles = sortTiles(tiles);
        if (tile < Card.Plum && tiles.slice(0, 4).join('') === [Card.Spring, Card.Summer, Card.Autumn, Card.Winter].join('')) {
            return 1;
        }
        if (tile > Card.Winter && tiles.slice(len - 4).join('') === [Card.Plum, Card.Orchid, Card.Bamboo, Card.Chrysanthemum].join('')) {
            return 2;
        }
    }
    return 0;
}
var dragon = [Card.Green, Card.Red, Card.White];
var pointEye = [2, 5, 8];
// 是否有番
function hasPoint(player) {
    if (player.hasPoint) {
        return true;
    }
    // 判断门前清
    if (!player.chowTiles.length) {
        return true;
    }
    var pick = player.pick;
    var order = player.round.game.order;
    var banker = player.round.game.banker;
    var point = (pick + 4 - banker) % 4 + 1;
    // 判断花
    if (player.flowerTiles.length && _.findIndex(player.flowerTiles, function (tile) { return (tile - 50) % 4 === point; }) > -1) {
        player.hasPoint = true;
        return true;
    }
    var dragonTiles = dragon.slice().concat([(point - 1) * 2 + 31, (order - 1) * 2 + 31]);
    var needPoint = false;
    var len = player.chowTiles.length;
    // 判断吃的牌是否有三张相同的红中、发财、白板或者令牌，四条有番
    if (len) {
        for (var i = 0; i < len; i++) {
            var meld = player.chowTiles[i];
            if (meld.type === ClaimType.Pong && dragonTiles.indexOf(meld.tiles[0]) > -1) {
                player.hasPoint = true;
                break;
            }
            if (meld.type === ClaimType.ConcealedKong || meld.type === ClaimType.Expose) {
                player.hasPoint = true;
                break;
            }
            // 有碰，需要番
            if (meld.type === ClaimType.Pong) {
                needPoint = true;
            }
        }
        if (player.hasPoint) {
            return true;
        }
    }
    var eye = player.eye[0][0];
    var groups = _.groupBy(player.handTiles, function (tile) {
        return tile / 1;
    });
    // 对子是中、发、白，需要番
    if (!needPoint) {
        if (dragonTiles.indexOf(eye) > -1) {
            needPoint = true;
        }
    }
    var hasPoint = false;
    var keys = Object.keys(groups);
    // 手牌有三张相同的，需要番
    if (!needPoint) {
        for (var j = 0, kLen = keys.length; j < kLen; j++) {
            var group = groups[keys[j]];
            if (group.length === 3 && group[0] !== eye) {
                needPoint = true;
                continue;
            }
            if (group.length === 3 && dragonTiles.indexOf(group[0]) > -1) {
                hasPoint = true;
            }
        }
    }
    if (needPoint) {
        for (var j = 0, kLen = keys.length; j < kLen; j++) {
            var group = groups[keys[j]];
            if (group.length === 3 && dragonTiles.indexOf(group[0]) > -1) {
                hasPoint = true;
                break;
            }
        }
        // 258
        // 手牌有三张相同的红中、发财、白板或者令牌
        if ((eye < Card.East && pointEye.indexOf(eye % 10) > -1) || hasPoint) {
            return true;
        }
    }
    else {
        return true;
    }
    return false;
}
// 检查牌成组的牌
function checkMelds(tiles, player) {
    var orderGroups = groupByOrder(tiles, 1);
    var remainTiles = [];
    if (player) {
        player.eye = [];
    }
    orderGroups.forEach(function (group) {
        var len = group.length;
        var remainder = len % 3;
        if (remainder === 0 || remainder === 2) {
            var size = groupSize(group);
            var table = remainder === 2 ? eyeAssembly[len] : assembly[len];
            if (_.indexOf(table, size) === -1) {
                remainTiles = remainTiles.concat(group);
                return;
            }
            // 找出将
            if (remainder === 2 && player) {
                player.eye.push(getEye(group, size));
            }
        }
        else {
            remainTiles = remainTiles.concat(group);
        }
    });
    return remainTiles;
}
// 找出是否可以听牌，听什么牌 
function checkReadyHand(player) {
    var remainTiles = player.remainTiles;
    var eye = player.eye;
    var len = remainTiles.length;
    var eyeLen = eye.length;
    player.readyHand = {};
    if (player.handTiles.length === 14) {
        // 七小对，十三幺
        var readyTiles = checkPair(player.handTiles);
        if (readyTiles.length === 2) {
            player.readyHand[readyTiles[0]] = [readyTiles[1]];
            player.readyHand[readyTiles[1]] = [readyTiles[0]];
            return;
        }
        var readyTile = checkUniq(player.handTiles);
        if (readyTile > 0) {
            player.readyHand[readyTile] = thirteenOrphans;
            return;
        }
    }
    if (eyeLen > 2) {
        return;
    }
    if (len === 1) {
        if (eyeLen === 2) {
            // 对碰
            player.readyHand[remainTiles[0]] = [eye[0][0], eye[1][0]];
        }
        return;
    }
    if (eyeLen === 2) {
        // 对碰
        if (len === 1) {
            player.readyHand[remainTiles[0]] = [eye[0][0], eye[1][0]];
            return;
        }
        remainTiles.forEach(function (tile, idx) {
            var newTiles = remainTiles.slice();
            newTiles.splice(idx, 1);
            if (!checkMelds(newTiles).length) {
                player.readyHand[tile] = [eye[0][0], eye[1][0]];
            }
        });
        if (!_.isEmpty(player.readyHand)) {
            return;
        }
    }
    if (len === 2) {
        if (eyeLen === 0) {
            // 单吊
            player.readyHand[remainTiles[0]] = [remainTiles[1]];
            player.readyHand[remainTiles[1]] = [remainTiles[0]];
        }
        return;
    }
    // 复杂的来了
    // 只能存在两种类型的牌，并且还要能和其他可连续
    var typeGroups = groupByType(remainTiles);
    var wordTiles = typeGroups.word;
    // 大字超过两个，而且不是最后两个，不可能听牌
    if (wordTiles && wordTiles.length >= 2) {
        return;
    }
    // 超过两个类型的不成组牌，不可能听牌
    var typeKeys = Object.keys(typeGroups);
    if (typeKeys.length > 2) {
        return;
    }
    // 把同花色的牌一起拿出来比较，这样找才全
    var tiles = sortTiles(player.handTiles);
    typeGroups = groupByType(tiles);
    var partTiles = [];
    typeKeys.forEach(function (type) {
        if (type === 'word') {
            return;
        }
        partTiles.push(typeGroups[type]);
    });
    // 如果有大字，肯定打大字才能听牌
    if (wordTiles) {
        partTiles.unshift(wordTiles);
    }
    player.readyHand = checkTing(partTiles);
    // 如果只有用一个剩余分组，并且只有一个目，那还要判断是否存在对碰的情况
    if (partTiles.length === 1 && eyeLen === 1 && partTiles[0].indexOf(eye[0][0]) === -1) {
        partTiles.push(eye[0]);
        var readyHand = checkTing(partTiles);
        if (!_.isEmpty(readyHand)) {
            for (var key in readyHand) {
                var item = player.readyHand[key];
                if (typeof item !== 'undefined') {
                    player.readyHand[key] = _.union(item, readyHand[key]);
                }
            }
        }
    }
}
// 七小对
function checkPair(tiles) {
    var groups = groupBy$1(tiles);
    var keys = Object.keys(groups);
    var len = keys.length;
    var readyTiles = [];
    if (len >= 7) {
        for (var i = 0; i < len; i++) {
            switch (groups[keys[i]].length) {
                case 3:
                    readyTiles.push(groups[keys[i]][0]);
                case 2:
                    break;
                case 1:
                    readyTiles.push(groups[keys[i]][0]);
                    break;
            }
        }
    }
    return readyTiles;
}
// 十三幺
function checkUniq(tiles) {
    var uniqTiles = _.uniq(sortTiles(tiles.slice()));
    if (uniqTiles.length === 14) {
        var remainTiles = _.pull.apply(_, [uniqTiles].concat(thirteenOrphans));
        if (!remainTiles.length) {
            return 0;
        }
        else if (remainTiles.length === 1) {
            return remainTiles[0];
        }
    }
    return -1;
}
// 检查出一张牌，抓什么牌可以成组
function checkTing(tileGroup) {
    var readyHand = {};
    var gLen = tileGroup.length;
    // 只有一个组，尝试打出每一张牌，剩下的牌抓一张能不能成组
    if (gLen === 1) {
        var tiles = tileGroup[0];
        var last = 0;
        for (var i = 0, len = tiles.length; i < len; i++) {
            var newTiles = tiles.slice();
            var tile = newTiles.splice(i, 1)[0];
            if (tile === last) {
                continue;
            }
            var tingTiles = canTing(newTiles);
            if (tingTiles.length) {
                readyHand[tile] = tingTiles;
            }
            last = tile;
        }
    }
    // 两个组，判断哪组花色可以出，哪组花色可以抓
    if (gLen === 2) {
        var groups = []; // [[[去掉的牌], [增加的牌]]]
        var group1 = tileGroup[0];
        var group2 = tileGroup[1];
        var group1Len = group1.length;
        var group2Len = group2.length;
        if (group1[0] >= Card.East) {
            // 如果有大字，肯定打大字才能听牌
            groups.push(tileGroup);
        }
        else {
            if (remain02(group1Len - 1) && remain02(group2Len + 1)) {
                groups.push([group1, group2]);
            }
            if (remain02(group2Len - 1) && remain02(group1Len + 1)) {
                groups.push([group2, group1]);
            }
        }
        groups.forEach(function (group) {
            var tiles = group[0];
            var last = 0;
            // 先看移除掉的组是否能成牌，能成牌才加牌
            for (var i = 0, len = tiles.length; i < len; i++) {
                var newTiles = tiles.slice();
                var tile = newTiles.splice(i, 1)[0];
                if (tile === last) {
                    continue;
                }
                var remainTiles = newTiles.length ? checkMelds(newTiles) : [];
                if (!remainTiles.length) {
                    var tingTiles = canTing(group[1]);
                    if (tingTiles.length) {
                        readyHand[tile] = tingTiles;
                    }
                }
                last = tile;
            }
        });
    }
    return readyHand;
}
// 检查抓什么牌可以成组
function canTing(tiles) {
    var tingTiles = [];
    var len = tiles.length;
    var base = 10 * Math.floor(tiles[0] / 10) + 1;
    var min = Math.max(tiles[0] - 1, base);
    var max$$1 = Math.min(tiles[len - 1] + 1, base + 8);
    for (var i = min; i <= max$$1; i++) {
        var remainTiles = checkMelds(sortTiles(tiles.concat([i])));
        if (!remainTiles.length) {
            tingTiles.push(i);
        }
    }
    return tingTiles;
}
// 将牌按[万、筒、条、大字]分组
function groupByType(tiles) {
    var characterTiles = [];
    var dotTiles = [];
    var bambooTiles = [];
    var wordTiles = [];
    var typeGroups = {};
    tiles.forEach(function (tile) {
        var i = Math.floor(tile / 10);
        switch (i) {
            case 0:
                characterTiles.push(tile);
                break;
            case 1:
                dotTiles.push(tile);
                break;
            case 2:
                bambooTiles.push(tile);
                break;
            default:
                wordTiles.push(tile);
                break;
        }
    });
    if (characterTiles.length) {
        typeGroups.character = characterTiles;
    }
    if (dotTiles.length) {
        typeGroups.dot = dotTiles;
    }
    if (bambooTiles.length) {
        typeGroups.bamboo = bambooTiles;
    }
    if (wordTiles.length) {
        typeGroups.word = wordTiles;
    }
    return typeGroups;
}

// 找到指定间距的顺序分组
function groupByOrder(allTiles, g) {
    if (g === void 0) { g = 1; }
    allTiles = allTiles.slice();
    var typeGroups = groupByType(allTiles);
    var groups = [];
    if (typeGroups.word) {
        _group(typeGroups.word);
    }
    if (typeGroups.character) {
        _group(typeGroups.character, g);
    }
    if (typeGroups.dot) {
        _group(typeGroups.dot, g);
    }
    if (typeGroups.bamboo) {
        _group(typeGroups.bamboo, g);
    }
    function _group(tiles, gap) {
        if (gap === void 0) { gap = 1; }
        var lastTile = tiles.splice(0, 1)[0];
        var group = [lastTile];
        var len = tiles.length;
        for (var i = 0; i < len; i++) {
            var tile = tiles[i];
            if (tile - lastTile <= gap) {
                group.push(tile);
            }
            else {
                groups.push(group);
                group = [tile];
            }
            lastTile = tile;
        }
        groups.push(group);
    }
    return groups;
}

// 看牌是不是能成组，条件是3 * n + 2?
function remain02(num) {
    var remainder = num % 3;
    return remainder === 0 || remainder === 2;
}
// 获取将牌
// tiles: 成组的牌, 12223; size: 每张牌的个数模型 131
// 尝试把大于2个数的牌取走，看剩下的牌能不能成组，能则说明这个就是将
function getEye(tiles, size) {
    var tilesLen = tiles.length;
    if (tilesLen === 2) {
        return tiles;
    }
    var eye = [];
    var sizes = size.toString().split('');
    var uniqTiles = _.uniq(tiles);
    var _loop_1 = function (i, len) {
        var item = parseInt(sizes[i]);
        if (item >= 2) {
            var flag_1 = true;
            var newSizes = sizes.slice();
            newSizes[i] = (item - 2).toString();
            newSizes = newSizes.join('').split('0');
            newSizes.forEach(function (item) {
                if (!item) {
                    return;
                }
                var i = parseInt(item);
                var s = getSizeLength(i);
                if (s % 3 !== 0 || _.indexOf(assembly[s], i) === -1) {
                    flag_1 = false;
                }
            });
            if (flag_1) {
                eye = _.fill(Array(2), uniqTiles[i]);
                return "break";
            }
        }
    };
    for (var i = 0, len = sizes.length; i < len; i++) {
        var state_1 = _loop_1(i, len);
        if (state_1 === "break")
            break;
    }
    return eye;
}
// 获取长度: 根据每张牌的个数模型; 
function getSizeLength(size) {
    return size.toString().split('').reduce(function (sum, val) {
        return sum + parseInt(val);
    }, 0);
}
// 获取每张牌个数模型
function groupSize(tiles) {
    var groups = groupBy$1(tiles);
    var sides = [];
    _.values(groups).forEach(function (group) {
        sides.push(group.length);
    });
    return parseInt(sides.join(''));
}
// 分组
function groupBy$1(tiles) {
    return _.groupBy(tiles, function (tile) {
        return tile / 1;
    });
}

// 是否可以行动
function canClaim(tiles, tile, canChow) {
    if (canChow === void 0) { canChow = true; }
    var melds = [];
    melds = checkPong(tiles, tile);
    if (canChow && tile < Card.East) {
        melds = melds.concat(checkChow(tiles, tile));
    }
    return melds;
}

// 杠
function canKong(tiles, tile) {
    var melds = [];
    var someTiles = getSomeTile(tiles, tile);
    var len = someTiles.length;
    if (len && len >= 4) {
        melds[0] = {
            tiles: someTiles.length === 4 ? someTiles : someTiles.concat(tile),
            type: ClaimType.ConcealedKong
        };
    }
    return melds;
}

// 碰
function checkPong(tiles, tile) {
    var melds = [];
    var someTiles = getSomeTile(tiles, tile);
    var len = someTiles.length;
    if (len && len >= 2) {
        melds = checkKong(someTiles, tile);
        melds[melds.length] = {
            tiles: melds.length ? someTiles : someTiles.concat(tile),
            type: ClaimType.Pong
        };
    }
    return melds;
}

function checkKong(tiles, tile) {
    var melds = [];
    if (tiles.length === 3) {
        melds[0] = {
            tiles: tiles.concat(tile),
            type: ClaimType.Expose
        };
    }
    return melds;
}

// 是否可以吃
function checkChow(tiles, tile) {
    var melds = [];
    var rangeTiles = getRangeTile(tiles, tile);
    var sequences = getSequence(rangeTiles, tile);
    melds = sequences.map(function (sequence) {
        return {
            tiles: sequence,
            type: ClaimType.Chow
        };
    });
    return melds;
}

// 获取相同的牌
function getSomeTile(tiles, tile) {
    var result = [];
    tiles.forEach(function (i) {
        if (i === tile) {
            result.push(i);
        }
    });
    return result;
}
// 获取指定范围的牌
function getRangeTile(tiles, tile) {
    var result = [];
    var min = Math.floor(tile / 10) * 10 + 1;
    var max$$1 = min + 8;
    var left = tile - 2;
    left = Math.max(left, min);
    var right = tile + 2;
    right = Math.min(right, max$$1);
    tiles.forEach(function (i) {
        if (i >= left && i <= right) {
            result.push(i);
        }
    });
    return result;
}
// 获取顺子
function getSequence(tiles, tile) {
    var melds = [];
    tiles = _.uniq(_.xor(tiles, [tile]));
    // 将牌组组成3个一起，然后判断是否是顺子
    if (tiles.length >= 2) {
        var sequences = [];
        for (var i = 0; i < tiles.length - 1; i++) {
            sequences.push([tiles[i], tiles[i + 1], tile]);
        }
        sequences.forEach(function (meld) {
            var newMeld = sortTiles(meld);
            if (newMeld[0] === newMeld[1] - 1 && newMeld[2] === newMeld[1] + 1) {
                melds.push(meld);
            }
        });
    }
    return melds;
}
//# sourceMappingURL=basic.js.map

var WinType;
(function (WinType) {
    WinType[WinType["CommonHand"] = 1] = "CommonHand";
    WinType[WinType["Uniform"] = 2] = "Uniform";
    WinType[WinType["Pong"] = 3] = "Pong";
    WinType[WinType["Pair"] = 4] = "Pair";
    WinType[WinType["LuxuryPair"] = 5] = "LuxuryPair";
    WinType[WinType["Uniq"] = 6] = "Uniq"; // 十三幺
})(WinType || (WinType = {}));

// 奖励类型
var BonusType;
(function (BonusType) {
    BonusType[BonusType["Win"] = 1] = "Win";
    BonusType[BonusType["SelfDraw"] = 2] = "SelfDraw";
    BonusType[BonusType["Kong"] = 3] = "Kong";
    BonusType[BonusType["Sky"] = 4] = "Sky";
    BonusType[BonusType["Land"] = 5] = "Land";
    BonusType[BonusType["FlowerSeason"] = 6] = "FlowerSeason";
    BonusType[BonusType["FlowerBotany"] = 7] = "FlowerBotany";
    BonusType[BonusType["Expose"] = 8] = "Expose";
    BonusType[BonusType["ConcealedKong"] = 9] = "ConcealedKong";
    BonusType[BonusType["BaoPai"] = 10] = "BaoPai";
    BonusType[BonusType["Cannon"] = 11] = "Cannon";
    BonusType[BonusType["FirstFollow"] = 12] = "FirstFollow"; // 首张被跟
})(BonusType || (BonusType = {}));

var thirteenOrphans$1 = [
    Card.CharacterOne,
    Card.CharacterNight,
    Card.DotOne,
    Card.DotNight,
    Card.BambooOne,
    Card.BambooNight,
    Card.East,
    Card.South,
    Card.West,
    Card.North,
    Card.Green,
    Card.Red,
    Card.White
];
function calculate(round) {
    var players = round.players;
    var winner = players[round.winner];
    var banker = round.game.banker;
    var bankerCount = round.game.bankerCount + 1;
    var cannons = _.fill(Array(players.length), 0); // 放炮、接炮
    players.forEach(function (player) {
        checkKong$1(player, players, cannons);
        checkFlower(player);
    });
    var winScore = checkWin(winner);
    if (winner.winFrom > -1) {
        players[winner.winFrom].bonus.push(BonusType.Cannon);
        cannons[winner.pick] += 1;
        cannons[winner.winFrom] -= 1;
    }
    var isBaoPai = winner.fourMeld;
    if (winner.threeMeld > -1 && winner.winFrom === winner.threeMeld) {
        isBaoPai = winner.threeMeld;
    }
    if (round.wall.willDead()) {
        isBaoPai = winner.winFrom;
    }
    // 包牌
    if (isBaoPai > -1) {
        compute(players, banker, bankerCount);
        players[isBaoPai].bonus.push(BonusType.BaoPai);
        var base = 1;
        var score = 0;
        if (winner.pick === banker) {
            base = bankerCount;
        }
        for (var i = 0, len = players.length; i < len; i++) {
            if (i === winner.pick) {
                continue;
            }
            if (i === banker) {
                base = bankerCount;
            }
            score += winScore * base;
        }
        winner.score += score;
        players[isBaoPai].score -= score;
    }
    else {
        winner.score += winScore;
        compute(players, banker, bankerCount);
    }
    addCannon(players, cannons);
    // 首张被跟
    if (_.indexOf(players[banker].bonus, BonusType.FirstFollow) > -1) {
        players.forEach(function (player, i) {
            if (i === banker) {
                player.score -= 3;
                return;
            }
            player.score += 1;
        });
    }
}
// 计算分数
function compute(players, banker, bankerCount) {
    var len = players.length;
    var bonus = _.fill(Array(len), 0); // 计算得分
    for (var i = 0; i < len; i++) {
        var player = players[i];
        if (player.score <= 0) {
            continue;
        }
        var base = 1;
        if (i === banker) {
            base = bankerCount;
        }
        for (var j = 0; j < len; j++) {
            var b = base;
            if (j === i) {
                continue;
            }
            if (j === banker) {
                b = bankerCount;
            }
            var s = player.score * b;
            bonus[i] += s;
            bonus[j] -= s;
        }
    }
    for (var i = 0; i < len; i++) {
        players[i].score = bonus[i];
    }
}
// 添加放炮、接炮得分
function addCannon(players, cannons) {
    players.forEach(function (player, i) {
        player.score += cannons[i];
    });
}
// 计算胡的牌型和分数
function checkWin(player) {
    var bonus = player.bonus, chowTiles = player.chowTiles, handTiles = player.handTiles;
    var winType = bonus.slice().sort(function (a, b) {
        return a - b;
    })[0];
    var base = 1;
    // 检查牌型
    var tiles = handTiles;
    chowTiles.forEach(function (meld) {
        tiles = tiles.concat(meld.tiles);
    });
    // 清一色
    if (checkOneType(tiles)) {
        base += 1;
        player.winType.push(WinType.Uniform);
    }
    var size = groupSize(handTiles);
    // 碰碰胡
    if (checkAllPong(chowTiles, size)) {
        base += 1;
        player.winType.push(WinType.Pong);
    }
    if (handTiles.length === 14) {
        if (checkPair$1(size)) {
            // 七小对
            base += 1;
            player.winType.push(WinType.Pair);
        }
        else if (checkLuxuryPair(size)) {
            // 豪华七小对
            base += 2;
            player.winType.push(WinType.LuxuryPair);
        }
        else if (checkUniq$1(handTiles)) {
            // 十三幺
            base += 12;
            player.winType.push(WinType.Uniq);
        }
    }
    if (!player.winType.length) {
        player.winType.push(WinType.CommonHand);
    }
    switch (winType) {
        case BonusType.Win:
            base *= 1;
            break;
        case BonusType.SelfDraw:
            base *= 2;
            break;
        case BonusType.Kong:
            base *= 3;
            break;
        case BonusType.Sky:
            base *= 3;
            break;
        case BonusType.Land:
            base *= 3;
            break;
    }
    return base;
}
// 清一色
function checkOneType(tiles) {
    var typeGroups = Object.keys(groupByType(tiles));
    return typeGroups.length === 1;
}
// 碰碰胡
function checkAllPong(chowTiles, size) {
    for (var i = 0, len = chowTiles.length; i < len; i++) {
        if (chowTiles[i].type < ClaimType.Pong) {
            return false;
        }
    }
    return _.pull(size.toString().split(''), '3').length === 1;
}
// 七小对
function checkPair$1(size) {
    return !_.pull(size.toString().split(''), '2').length;
}
// 豪华七小对
function checkLuxuryPair(size) {
    var remain = _.pull(size.toString().split(''), '2');
    return remain.length === 1 && remain[0] === '4';
}
// 十三幺
function checkUniq$1(tiles) {
    var uniqTiles = _.uniq(sortTiles(tiles.slice()));
    return uniqTiles.length === 13 && _.isEqual(uniqTiles, thirteenOrphans$1);
}
// 花胡
function checkFlower(player) {
    if (_.indexOf(player.bonus, BonusType.FlowerSeason) > -1) {
        player.score += 1;
    }
    if (_.indexOf(player.bonus, BonusType.FlowerBotany) > -1) {
        player.score += 1;
    }
}
// 杠
function checkKong$1(player, players, cannons) {
    player.chowTiles.forEach(function (meld) {
        if (meld.type === ClaimType.Expose) {
            player.score += 1;
            player.bonus.push(BonusType.Expose);
            players[meld.from].bonus.push(BonusType.Cannon);
            cannons[player.pick] += 1;
            cannons[meld.from] -= 1;
        }
        if (meld.type === ClaimType.ConcealedKong || meld.type === ClaimType.ExposeSelfDraw) {
            player.score += 2;
            player.bonus.push(BonusType.ConcealedKong);
        }
    });
}
//# sourceMappingURL=bonus.js.map

var PlayerDetail = /** @class */ (function (_super) {
    __extends(PlayerDetail, _super);
    function PlayerDetail(id, name, pick, isAI) {
        if (isAI === void 0) { isAI = false; }
        var _this = _super.call(this, id, name, pick, isAI) || this;
        _this.handTiles = [];
        _this.discardTiles = [];
        _this.flowerTiles = [];
        _this.chowTiles = [];
        _this.hasDiscard = false;
        _this.readyHand = {};
        _this.readyHandTiles = [];
        _this.canWin = true;
        _this.eye = [];
        _this.remainTiles = [];
        _this.score = 0;
        _this.winFrom = -1;
        _this.winType = [];
        _this.bonus = [];
        _this.threeMeld = -1;
        _this.fourMeld = -1;
        _this.melds = [];
        _this.discardClaim = false;
        _this.hasPoint = false;
        return _this;
    }
    // 开始
    PlayerDetail.prototype.start = function (round, isBanker) {
        var _this = this;
        this.round = round;
        this.wall = round.wall;
        this.isBanker = isBanker;
        this.discardClaim = isBanker;
        this.openHand();
        // 补花
        if (isBanker) {
            setTimeout(function () {
                _this.openCheck();
            }, 0);
        }
    };
    // 起牌
    PlayerDetail.prototype.openHand = function () {
        this.handTiles = this.wall.openHand(this.isBanker);
        this.sort();
        console.log('open', this.name, batchTilesSuit(this.handTiles));
    };
    // 抽牌
    PlayerDetail.prototype.deal = function () {
        this.discardClaim = true;
        var tile = this.wall.deal();
        if (tile === -1) {
            this.round.draw();
            return;
        }
        this.handTiles.push(tile);
        this.check(tile, false);
    };
    // 后面抽牌
    PlayerDetail.prototype.draw = function () {
        this.discardClaim = true;
        var tile = this.wall.draw();
        if (tile === -1) {
            this.round.draw();
            return;
        }
        this.handTiles.push(tile);
        if (this.handTiles.length % 3 !== 2) {
            return;
        }
        this.check(tile, true);
    };
    // 出牌
    PlayerDetail.prototype.discard = function (tile) {
        var i = this.handTiles.indexOf(tile);
        this.discardClaim = false;
        this.handTiles.splice(i, 1)[0];
        this.discardTiles.push(tile);
        this.sort();
        this.hasDiscard = true;
        var keys = Object.keys(this.readyHand);
        if (keys.length) {
            var idx = keys.indexOf(tile.toString());
            if (idx > -1) {
                this.readyHandTiles = this.readyHand[tile];
            }
        }
        else {
            this.readyHandTiles = [];
        }
        this.round.check(tile);
    };
    // 出的牌被别人吃的，要移交给别人
    PlayerDetail.prototype.tranfer = function () {
        this.discardTiles.pop();
    };
    // 其他玩家出牌回合，检查自己是否需要这张牌
    PlayerDetail.prototype.checkClaim = function (tile, canChow) {
        this.melds = [];
        var melds = [];
        if (this.checkWin(tile) && hasPoint(this)) {
            melds.push({
                type: ClaimType.Win,
                tiles: []
            });
        }
        melds = melds.concat(canClaim(this.handTiles, tile, canChow));
        if (melds.length) {
            melds.push({
                type: ClaimType.None,
                tiles: []
            });
            this.melds = melds;
        }
        return !!melds.length;
    };
    // 玩家选择行动
    PlayerDetail.prototype.claim = function (idx) {
        this.meld = this.melds[idx];
        console.log('claim', this.name, idx, this.melds);
        if (this.meld) {
            if (this.pick === this.round.player) {
                this.action(-1);
            }
            else {
                this.round.claim(this.pick, this.meld.type);
            }
        }
    };
    // 真正的行动
    PlayerDetail.prototype.action = function (from) {
        var meld = __assign({}, this.meld, { from: from // -1表示自己
         });
        console.log('action', this.name, meld);
        switch (meld.type) {
            // 胡牌，结束
            case ClaimType.Win:
            case ClaimType.SelfDraw:
            case ClaimType.Kong:
                var type = ClaimType[meld.type];
                this.winFrom = from;
                this.win(type);
                this.round.finish(this.pick);
                break;
            // 杠
            case ClaimType.ConcealedKong:
            case ClaimType.Expose:
                this.pull(meld);
                this.chowTiles.push(meld);
                this.checkBaoPai();
                this.draw();
                break;
            // 碰牌杠
            case ClaimType.ExposeSelfDraw:
                this.checkBaoPai();
                this.draw();
                break;
            // 碰、胡
            case ClaimType.Chow:
            case ClaimType.Pong:
                this.pull(meld);
                this.chowTiles.push(meld);
                this.checkBaoPai();
                this.discardClaim = true;
                break;
        }
        // 吃完牌后检查是否听牌
        canReadyHand(this);
    };
    // 判断是否包牌
    PlayerDetail.prototype.checkBaoPai = function () {
        var chowTiles = this.chowTiles;
        var len = chowTiles.length;
        if (len >= 3) {
            var groups = _.groupBy(chowTiles, 'from');
            var keys = Object.keys(groups);
            var kLen = keys.length;
            if (kLen > 2) {
                return;
            }
            if ((len === 3 && kLen === 1)) {
                this.threeMeld = parseInt(keys[0]);
                return;
            }
            if (len === 4) {
                if (kLen === 1) {
                    this.fourMeld = parseInt(keys[0]);
                    this.threeMeld = -1;
                }
                else if (kLen === 2) {
                    if (groups[keys[0]].length === 3) {
                        this.threeMeld = parseInt(keys[0]);
                    }
                    else {
                        this.threeMeld = parseInt(keys[1]);
                    }
                }
                return;
            }
        }
    };
    // 天胡、地胡
    PlayerDetail.prototype.win = function (type) {
        if (!this.hasDiscard && !this.flowerTiles.length) {
            // 手牌胡
            type = this.isBanker ? 'Sky' : 'Land';
        }
        this.bonus.push(BonusType[type]);
    };
    // 自己摸牌回合检查
    PlayerDetail.prototype.check = function (tile, isDraw) {
        this.melds = [];
        if (sortTiles(this.handTiles.slice()).slice(-1)[0] >= Card.Spring) {
            this.checkFlower();
            return;
        }
        var melds = [];
        if (this.checkWin(tile, true)) {
            melds.push({
                type: isDraw ? ClaimType.Kong : ClaimType.SelfDraw,
                tiles: []
            });
        }
        melds = melds.concat(canKong(this.handTiles, tile));
        for (var i = 0, len = this.chowTiles.length; i < len; i++) {
            var meld = this.chowTiles[i];
            if (meld.type === ClaimType.Pong && meld.tiles[0] === tile) {
                meld.tiles = [tile, tile, tile, tile];
                meld.type = ClaimType.ExposeSelfDraw;
                melds.push({
                    type: ClaimType.ExposeSelfDraw,
                    tiles: []
                });
            }
        }
        if (melds.length) {
            this.melds = melds;
            return;
        }
        canReadyHand(this);
    };
    // 胡牌
    PlayerDetail.prototype.checkWin = function (tile, bySelf) {
        if (bySelf === void 0) { bySelf = false; }
        if (!this.hasDiscard || (this.readyHandTiles.length && this.readyHandTiles.indexOf(tile) > -1)) {
            // 再检查下是否能胡
            return bySelf ? canWin(this) : canWin(this, tile);
        }
        return false;
    };
    // 补花
    PlayerDetail.prototype.checkFlower = function () {
        var _this = this;
        var tiles = [];
        var handTiles = sortTiles(this.handTiles.slice());
        var idx = _.findIndex(handTiles, function (tile) { return tile >= Card.Spring; });
        if (idx > -1) {
            tiles = handTiles.splice(idx, handTiles.length - idx);
        }
        if (!tiles.length) {
            return;
        }
        tiles.forEach(function (tile) {
            _this.handTiles.splice(_this.handTiles.indexOf(tile), 1);
        });
        tiles.forEach(function (tile) {
            if (tile >= Card.Spring) {
                _this.flowerTiles.push(tile);
                _this.flowerTiles = sortTiles(_this.flowerTiles);
                _this.draw();
                var count = canFlowerWin(_this.flowerTiles, tile);
                if (count) {
                    count === 1 ? _this.bonus.push(BonusType.FlowerSeason) : _this.bonus.push(BonusType.FlowerBotany);
                }
            }
        });
    };
    PlayerDetail.prototype.openCheck = function () {
        var melds = [];
        if (this.checkWin(0, true)) {
            melds.push({
                type: ClaimType.SelfDraw,
                tiles: []
            });
        }
        var groups = _.groupBy(this.handTiles, function (tile) {
            return tile / 1;
        });
        Object.keys(groups).forEach(function (key) {
            var group = groups[key];
            if (group.length === 4) {
                melds.push({
                    type: ClaimType.ConcealedKong,
                    tiles: group
                });
            }
        });
        if (melds.length) {
            this.melds = melds;
        }
        this.checkFlower();
        canReadyHand(this);
    };
    PlayerDetail.prototype.sort = function () {
        this.handTiles = sortTiles(this.handTiles);
    };
    PlayerDetail.prototype.pull = function (meld) {
        var type = meld.type;
        var tiles = meld.tiles.slice(0, -1);
        var handTiles = this.handTiles;
        if (type === ClaimType.Expose || type === ClaimType.ConcealedKong) {
            _.pull.apply(_, [handTiles].concat(tiles));
            return;
        }
        tiles.forEach(function (tile) {
            handTiles.splice(handTiles.indexOf(tile), 1);
        });
    };
    return PlayerDetail;
}(Player$1));

//# sourceMappingURL=playerDetail.js.map

var PlayerAIBasic = /** @class */ (function (_super) {
    __extends(PlayerAIBasic, _super);
    function PlayerAIBasic(id, name, pick) {
        return _super.call(this, id, name, pick, true) || this;
    }
    PlayerAIBasic.prototype.start = function (round, isBanker) {
        var _this = this;
        _super.prototype.start.call(this, round, isBanker);
        if (isBanker && this.handTiles.slice(-1)[0] < Card.Spring) {
            setTimeout(function () {
                if (_this.melds.length) {
                    _this.claimByAI();
                }
                _this.discardByAI();
            }, 100);
        }
    };
    // 抽牌
    PlayerAIBasic.prototype.deal = function () {
        var flowerLen = this.flowerTiles.length;
        var chowLen = this.chowTiles.length;
        _super.prototype.deal.call(this);
        if (flowerLen < this.flowerTiles.length || chowLen < this.chowTiles.length) {
            return;
        }
        if (this.melds.length) {
            this.claimByAI();
            return;
        }
        this.discardByAI();
    };
    // 后面抽牌
    PlayerAIBasic.prototype.draw = function () {
        _super.prototype.draw.call(this);
        if (this.handTiles.length % 3 !== 2 || this.handTiles.slice(-1)[0] >= Card.Spring) {
            return;
        }
        if (this.melds.length) {
            this.claimByAI();
            return;
        }
        this.discardByAI();
    };
    PlayerAIBasic.prototype.checkClaim = function (tile, canChow) {
        var _this = this;
        var hasClaim = _super.prototype.checkClaim.call(this, tile, canChow);
        if (hasClaim && this.melds.length) {
            // 延迟后响应
            setTimeout(function () {
                _this.claimByAI();
            }, 500);
        }
        return hasClaim;
    };
    // 决定行动哪个
    PlayerAIBasic.prototype.claimByAI = function () {
        var _this = this;
        // 找出行动的大小，行动最大的
        var melds = this.melds;
        var claims = melds.map(function (meld) { return meld.type; });
        var claim = _.max(claims);
        if (typeof claim !== 'undefined') {
            var idx = claims.indexOf(claim);
            // 如果以听牌，不吃不碰
            if (claim <= ClaimType.Pong && !_.isEmpty(this.readyHand)) {
                _super.prototype.claim.call(this, claims.length - 1);
                return;
            }
            // 如果这不是remainTiles的牌，不吃
            if (claim === ClaimType.Chow) {
                var remainTiles = _.uniq(this.remainTiles.slice());
                var union$$1 = _.union(remainTiles, melds[idx].tiles.slice(0, -1));
                if (union$$1.length !== remainTiles.length) {
                    // 如果还有其他的吃牌组合，继续判断
                    if (melds.length > 2) {
                        melds.splice(0, 1);
                        this.claimByAI();
                        return;
                    }
                    _super.prototype.claim.call(this, claims.length - 1);
                    return;
                }
            }
            _super.prototype.claim.call(this, idx);
            setTimeout(function () {
                // 如果胡牌、杠，不继续
                if (claim >= ClaimType.Expose || _this.round.winner > -1) {
                    return;
                }
                if (_this.round.player === _this.pick) {
                    _this.discardByAI();
                }
            }, 500);
        }
    };
    // 决定出哪张牌
    PlayerAIBasic.prototype.discardByAI = function () {
        var _this = this;
        var tile = 0;
        if (!_.isEmpty(this.readyHand)) {
            console.log('readyhand', JSON.stringify(this.readyHand));
            // 如果听牌，最简单
            var keys = Object.keys(this.readyHand);
            // 从牌面算概率，听哪张牌赢得概率最大
            if (keys.length > 1) {
                var tiles = keys.map(function (key) { return _this.readyHand[key]; });
                var probabilities_1 = this.probabilityCalculate(_.concat.apply(_, [[]].concat(tiles)), true);
                var max_1 = -1;
                keys.forEach(function (key) {
                    var p = 0;
                    _this.readyHand[key].forEach(function (tile) {
                        p += probabilities_1[tile];
                    });
                    if (p > max_1) {
                        tile = parseInt(key);
                        max_1 = p;
                    }
                });
                // TODO: 会出现叫死牌的情况
            }
            else {
                tile = parseInt(keys[0]);
            }
        }
        else {
            // 否则，找单牌出
            var remainTiles = sortTiles(this.remainTiles);
            var len = remainTiles.length;
            console.log('remain', remainTiles);
            if (len) {
                var tiles_1 = [];
                // 优先出大字
                tiles_1 = _.filter(remainTiles, function (item) {
                    return item >= Card.East && item <= Card.Spring;
                });
                if (!tiles_1.length) {
                    // 找到不连续的牌
                    var groups = groupByOrder(remainTiles.slice(), 2);
                    groups.forEach(function (group) {
                        if (group.length === 1) {
                            tiles_1.push(group[0]);
                        }
                    });
                    if (!tiles_1.length) {
                        groups = groupByOrder(remainTiles.slice(), 1);
                        groups.forEach(function (group) {
                            if (group.length === 1) {
                                tiles_1.push(group[0]);
                            }
                        });
                    }
                    if (!tiles_1.length) {
                        tiles_1 = remainTiles;
                    }
                    var oneAndNightTiles = _.filter(tiles_1, function (item) {
                        var r = item % 10;
                        return r === 1 || r === 9;
                    });
                    if (oneAndNightTiles.length) {
                        tiles_1 = oneAndNightTiles;
                    }
                }
                console.log('tiles', tiles_1);
                if (tiles_1.length === 1) {
                    tile = tiles_1[0];
                }
                else {
                    // 再从牌面看，优先出不会放炮的牌
                    var probabilities = this.probabilityCalculate(tiles_1);
                    var max$$1 = 5;
                    for (var key in probabilities) {
                        if (probabilities[key] < max$$1) {
                            tile = parseInt(key);
                            max$$1 = probabilities[key];
                        }
                    }
                }
            }
        }
        if (tile) {
            console.log('discard', this.name, batchTilesSuit([tile]));
            _super.prototype.discard.call(this, tile);
        }
    };
    PlayerAIBasic.prototype.probabilityCalculate = function (tiles, addHandTile) {
        if (addHandTile === void 0) { addHandTile = false; }
        var probabilities = {};
        var players = this.round.players;
        var visibleTiles = _.concat.apply(_, [[]].concat(players.map(function (player) {
            return player.discardTiles.concat(_.concat.apply(_, [[]].concat(player.chowTiles.map(function (meld) { return meld.tiles; }))));
        })));
        if (addHandTile) {
            visibleTiles.splice.apply(visibleTiles, [visibleTiles.length, 0].concat(this.handTiles));
        }
        var groups = _.groupBy(visibleTiles, function (tile) {
            return tile / 1;
        });
        tiles.forEach(function (tile) {
            probabilities[tile] = 4;
            if (groups[tile]) {
                probabilities[tile] = 4 - groups[tile].length;
            }
        });
        return probabilities;
    };
    return PlayerAIBasic;
}(PlayerDetail));

//# sourceMappingURL=basic.js.map

var Wall = /** @class */ (function () {
    function Wall(hasWind, hasDragon, hasFlower) {
        if (hasWind === void 0) { hasWind = true; }
        if (hasDragon === void 0) { hasDragon = true; }
        if (hasFlower === void 0) { hasFlower = true; }
        this.tiles = shuffleTiles(getTiles(hasWind, hasDragon, hasFlower));
    }
    Wall.prototype.openHand = function (isBanker) {
        return this.tiles.splice(0, isBanker ? 14 : 13);
    };
    Wall.prototype.isDead = function () {
        return this.tiles.length < 16;
    };
    // 海底包牌
    Wall.prototype.willDead = function () {
        return this.tiles.length >= 16 && this.tiles.length <= 19;
    };
    // 摸牌
    Wall.prototype.deal = function () {
        if (this.isDead()) {
            return -1;
        }
        return this.tiles.shift() || -1;
    };
    // 花杠
    Wall.prototype.draw = function () {
        if (this.isDead()) {
            return -1;
        }
        return this.tiles.pop() || -1;
    };
    return Wall;
}());

//# sourceMappingURL=wall.js.map

var defaultOrder = [0, 1, 2, 3];
// 局
var Round = /** @class */ (function () {
    function Round(game) {
        var _this = this;
        this.game = game;
        this.players = [];
        game.players.forEach(function (player) {
            _this.addPlayer(player.id, player.name, player.pick, player.isAI);
        });
        this.claims = [-1, -1, -1, -1];
        this.canClaims = [0, 0, 0, 0];
        this.firstFlow = 4;
        this.winner = -1;
    }
    Round.prototype.addPlayer = function (id, name, pick, isAI) {
        if (isAI === void 0) { isAI = false; }
        var player = isAI ? new PlayerAIBasic(id, name, pick) : new PlayerDetail(id, name, pick);
        this.players.push(player);
    };
    // 开局
    Round.prototype.start = function () {
        var _this = this;
        this.wall = new Wall();
        var banker = this.game.banker;
        var order = defaultOrder.slice(banker).concat(defaultOrder.slice(0, banker));
        this.player = banker;
        order.forEach(function (pick, i) {
            _this.players[pick].start(_this, !i);
        });
    };
    // 结束
    Round.prototype.finish = function (player) {
        this.winner = player;
        console.log('win', this.winner, batchTilesSuit(this.players[player].handTiles), this.players[player].chowTiles, this.players[player].bonus);
        calculate(this);
        this.game.finish();
    };
    // 流局
    Round.prototype.draw = function () {
        console.log('draw', '---------');
        this.winner = this.game.banker;
        this.game.finish();
    };
    // 上家出牌，检查哪个玩家能行动
    Round.prototype.check = function (tile) {
        var _this = this;
        this.checkFirstFlow(tile);
        this.players.forEach(function (player, i) {
            if (_this.player === i) {
                return;
            }
            _this.canClaims[i] = player.checkClaim(tile, i === _this.getNext()) ? 1 : 0;
        });
        // 大家都不能行动，直接下家
        // 大家能行动，等待行动指令
        if (this.canClaims.join('') === '0000') {
            this.next();
        }
    };
    // 玩家行动
    Round.prototype.claim = function (player, claim) {
        this.firstFlow = 0; // 有人行动，就不会形成首张被跟
        this.claims[player] = claim;
        console.log('player claim', this.players[player].name, this.canClaims, this.claims);
        // 所有玩家都行动完，检查谁可以行动
        if (_.pull(this.canClaims.slice(), 0).length === _.pull(this.claims.slice(), -1).length) {
            // 如果大家都不行动
            if (_.uniq(_.pull(this.claims.slice(), -1)).join('') === '0') {
                this.claims = [-1, -1, -1, -1];
                this.canClaims = [0, 0, 0, 0];
                this.next();
            }
            else {
                var idx = _.max(this.claims);
                if (idx) {
                    player = this.claims.indexOf(idx);
                    this.players[this.player].tranfer();
                    this.players[player].action(this.player);
                    this.player = player;
                }
                this.claims = [-1, -1, -1, -1];
                this.canClaims = [0, 0, 0, 0];
                if (!idx) {
                    this.next();
                }
            }
        }
    };
    // 谁行动
    Round.prototype.next = function () {
        if (this.winner > -1) {
            return;
        }
        this.player = this.getNext();
        console.log('next player', this.players[this.player].name, '-------------');
        this.players.forEach(function (player) {
            console.log(player.name, batchTilesSuit(player.handTiles), '---', batchTilesSuit(player.discardTiles), '---', batchTilesSuit(player.flowerTiles), player.chowTiles);
        });
        this.players[this.player].deal();
    };
    // 检查首张被跟
    Round.prototype.checkFirstFlow = function (tile) {
        // 第4轮检查大家手牌，看是不是首张被跟
        if (!this.firstFlow) {
            return;
        }
        else {
            var flag = true;
            for (var i = 0, len = this.players.length; i < len; i++) {
                if (i === this.player) {
                    continue;
                }
                var player = this.players[i];
                if (player.discardTiles.length && player.discardTiles[0] !== tile) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                if (this.firstFlow === 1) {
                    this.players[this.game.banker].bonus.push(BonusType.FirstFollow);
                }
                this.firstFlow--;
            }
            else {
                this.firstFlow = 0;
            }
        }
    };
    Round.prototype.getNext = function () {
        return (this.player + 1) % 4;
    };
    return Round;
}());

//# sourceMappingURL=round.js.map

var Game = /** @class */ (function () {
    function Game() {
        this.order = Pick.East;
        this.banker = 0;
        this.bankerCount = 0;
        this.bonus = [];
        this.players = [];
        this.rounds = [];
    }
    // 添加玩家
    Game.prototype.addPlayer = function (id, name, isAI) {
        if (isAI === void 0) { isAI = false; }
        var len = this.players.length;
        if (len >= 4) {
            console.log('座位已满!');
            return;
        }
        var player = new Player$1(id, name, len, isAI);
        this.players.push(player);
    };
    // 开局
    Game.prototype.start = function () {
        if (this.players.length < 4) {
            console.log('人数不够，不能开始!');
            return;
        }
        var round = new Round(this);
        round.start();
        this.rounds.push(round);
    };
    // 本局结束，进入下一局
    Game.prototype.finish = function () {
        var len = this.rounds.length;
        if (len) {
            // 换庄
            var round = this.rounds[len - 1];
            if (round.winner !== this.banker) {
                this.banker++;
                this.bankerCount = 0;
                if (this.banker > 3) {
                    this.banker = 0;
                    this.order++;
                }
                if (this.order > 4) {
                    this.order = Pick.East;
                }
            }
            else {
                this.bankerCount++;
            }
            // 下一局
            // this.start();
        }
    };
    Game.prototype.end = function () {
        for (var i = 0, len = this.players.length; i < len; i++) {
            this.bonus[i] = 0;
        }
        var bonus = this.bonus;
        this.rounds.forEach(function (round) {
            round.players.forEach(function (player, i) {
                bonus[i] += player.score;
            });
        });
    };
    return Game;
}());

//# sourceMappingURL=game.js.map

// import './tile';
// import './player';
// import './rules/basic';
// import './ai/basic';
// const game = new Game();
// game.addPlayer(1, 'test1', true);
// game.addPlayer(2, 'test2', true);
// game.addPlayer(3, 'test3', true);
// game.addPlayer(4, 'test4', true);
// game.start();
// const player = new Player(1, 'AI', 0);
// player.handTiles = [12, 12, 14, 14, 16, 17, 18, 21, 21, 22, 25, 25, 27, 29];
// canReadyHand(player);
var main = {
    Player: PlayerDetail,
    Game: Game
};

module.exports = main;
//# sourceMappingURL=mahjong.js.map
