/* eslint-disable */
import { DiagnosticCategory } from 'typescript';
import * as ts from 'typescript';
import { createFilter } from 'rollup-pluginutils';
import { existsSync, readFileSync, statSync } from 'fs';
import * as fs from 'fs';
import { sep } from 'path';
import * as path from 'path';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */



var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

function endsWith(str, tail) {
    return !tail.length || str.slice(-tail.length) === tail;
}

function getDefaultOptions() {
    return {
        noEmitHelpers: true,
        module: 'es2015',
        sourceMap: true
    };
}
// Gratefully lifted from 'look-up', due to problems using it directly:
//   https://github.com/jonschlinkert/look-up/blob/master/index.js
//   MIT Licenced
function findFile(cwd, filename) {
    var fp = cwd ? (cwd + '/' + filename) : filename;
    if (existsSync(fp)) {
        return fp;
    }
    var segs = cwd.split(sep);
    var len = segs.length;
    while (len--) {
        cwd = segs.slice(0, len).join('/');
        fp = cwd + '/' + filename;
        if (existsSync(fp)) {
            return fp;
        }
    }
    return null;
}
function compilerOptionsFromTsConfig(typescript) {
    var cwd = process.cwd();
    var tsconfig = typescript.readConfigFile(findFile(cwd, 'tsconfig.json'), function (path$$1) { return readFileSync(path$$1, 'utf8'); });
    if (!tsconfig.config || !tsconfig.config.compilerOptions)
        return {};
    return tsconfig.config.compilerOptions;
}
function adjustCompilerOptions(typescript, options) {
    // Set `sourceMap` to `inlineSourceMap` if it's a boolean
    // under the assumption that both are never specified simultaneously.
    if (typeof options.inlineSourceMap === 'boolean') {
        options.sourceMap = options.inlineSourceMap;
        delete options.inlineSourceMap;
    }
    // Delete the `declaration` option to prevent compilation error.
    // See: https://github.com/rollup/rollup-plugin-typescript/issues/45
    delete options.declaration;
    // Use importHelpers from TypeScript.
    options.importHelpers = true;
}

function readFile(fileName) {
    return readFileSync(fileName, 'utf8');
}
function directoryExists(dirPath) {
    try {
        return statSync(dirPath).isDirectory();
    }
    catch (err) {
        return false;
    }
}
function fileExists(filePath) {
    try {
        return statSync(filePath).isFile();
    }
    catch (err) {
        return false;
    }
}


var resolveHost = Object.freeze({
	readFile: readFile,
	directoryExists: directoryExists,
	fileExists: fileExists
});

// The injected id for helpers.
var TSLIB = 'tslib';
var tslibSource;
try {
    var tslibPath = require.resolve('tslib/' + require('tslib/package.json')['module']);
    tslibSource = readFileSync(tslibPath, 'utf8');
}
catch (e) {
    console.warn('Error loading `tslib` helper library.');
    throw e;
}
typescript['default'] = typescript;
function typescript(options) {
    options = __assign({}, options);
    var filter = createFilter(options.include || ['*.ts+(|x)', '**/*.ts+(|x)'], options.exclude || ['*.d.ts', '**/*.d.ts']);
    delete options.include;
    delete options.exclude;
    // Allow users to override the TypeScript version used for transpilation.
    var typescript = options.typescript || ts;
    delete options.typescript;
    // Load options from `tsconfig.json` unless explicitly asked not to.
    var tsconfig = options.tsconfig === false ? {} :
        compilerOptionsFromTsConfig(typescript);
    delete options.tsconfig;
    // Since the CompilerOptions aren't designed for the Rollup
    // use case, we'll adjust them for use with Rollup.
    adjustCompilerOptions(typescript, tsconfig);
    adjustCompilerOptions(typescript, options);
    // Merge all options.
    options = __assign({}, tsconfig, getDefaultOptions(), options);
    // Verify that we're targeting ES2015 modules.
    if (options.module !== 'es2015' && options.module !== 'es6') {
        throw new Error("rollup-plugin-typescript: The module kind should be 'es2015', found: '" + options.module + "'");
    }
    var parsed = typescript.convertCompilerOptionsFromJson(options, process.cwd());
    if (parsed.errors.length) {
        for (var _i = 0, _a = parsed.errors; _i < _a.length; _i++) {
            var error = _a[_i];
            console.error("rollup-plugin-typescript: " + error.messageText);
        }
        throw new Error("rollup-plugin-typescript: Couldn't process compiler options");
    }
    var compilerOptions = parsed.options;
    return {
        resolveId: function (importee, importer) {
            if (importee === TSLIB) {
                return '\0' + TSLIB;
            }
            if (!importer)
                return null;
            var result;
            importer = importer.split('\\').join('/');
            result = typescript.nodeModuleNameResolver(importee, importer, compilerOptions, resolveHost);
            if (result.resolvedModule && result.resolvedModule.resolvedFileName) {
                if (endsWith(result.resolvedModule.resolvedFileName, '.d.ts')) {
                    return null;
                }
                return result.resolvedModule.resolvedFileName;
            }
            return null;
        },
        load: function (id) {
            if (id === '\0' + TSLIB) {
                return tslibSource;
            }
        },
        transform: function (code, id) {
            if (!filter(id))
                return null;
            var transformed = typescript.transpileModule(code, {
                fileName: id,
                reportDiagnostics: true,
                compilerOptions: compilerOptions,
            });
            var diagnostics = transformed.diagnostics || [];
            var fatalError = false;
            for (var _i = 0, diagnostics_1 = diagnostics; _i < diagnostics_1.length; _i++) {
                var diagnostic = diagnostics_1[_i];
                var message = typescript.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
                if (diagnostic.file) {
                    var _a = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = _a.line, character = _a.character;
                    console.error(diagnostic.file.fileName + "(" + (line + 1) + "," + (character + 1) + "): error TS" + diagnostic.code + ": " + message);
                }
                else {
                    console.error("Error: " + message);
                }
                if (diagnostic.category === DiagnosticCategory.Error) {
                    fatalError = true;
                }
            }
            if (fatalError) {
                throw new Error("There were TypeScript errors transpiling");
            }
            return {
                // Always append an import for the helpers.
                code: transformed.outputText,
                // Rollup expects `map` to be an object so we must parse the string
                map: transformed.sourceMapText ? JSON.parse(transformed.sourceMapText) : null,
            };
        }
    };
}

export default typescript;
